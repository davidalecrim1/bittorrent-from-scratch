- [x] Decode bencoded strings from the bencode protocol of BitTorrent;
- [x] Decode integers;
- [x] Decode the lists;
- [x] Refactor the tests for this new logic of decoding;
- [x] Decode dictionaries;
- [x] Parse a torrent file and store its information about the server (a.k.a tracker) with the peers;
    - [x] Understand the problem of announce list.
    - [x] Add the feature of a list within a list.
    - [x] Add the feature of a dictionary within a dictionary (I will need to refactor things).
    - [x] Handle the pieces keyword to parse things as raw instead of string because of invalid UTF-8.
- [ ] Change the file parsing to a test instead of the main function.
- [x] Create a function to return the hash of the info.
- [x] Parse the pieces length and it's hashes into the bittorrent client.
- [x] Debug the request for the tracker to work on Postman.
- [x] Create the request for the tracker server.
- [x] Validate if my info hash is right using serde bencode.
- [x] Fix bug in list parsing with the end of a list.
- [x] Send a message to a peer and return the hash of the connection.
- [x] Start spliting into multiple files based on how rust manages modules.
- [ ] Download a piece of the file.
  - [x] Refactor the code structure to persist the connection and reuse it.
  - [x] Reuse the connection to write another message after a handshake.
  - [x] Parse the bitfield message into a struct to know which piece does the peer have;
  - [x] Add a test to make this parsing clear in the future;
  - [x] Send an interested message;
  - [x] Refactor the read messages using a channel to fix the ownership problem between two tasks in Rust;
    - [x] This should look like in Go with channels and a select. This seems the way to do it.
  - [x] Finish the refactor to ensure I found the best model for this concurrency model given the I/O operations;
  - [x] Understand the infinite loop that is happening with the bitfield message;
    - [x] This seems to be a decoder problem understading the unchoke messages as bitfield ones;
    - [x] This was a problem of not broadcasting the read bytes on the channel.
  - [ ] Send a request message and see if more refactor will be needed to make this work in Rust with the loop;
- [ ] Add retries to the tracker server given that the peers sometimes return a 503 or a message like this:
  [src/encoding.rs:333:13] &key = "peers"
  [src/encoding.rs:333:13] &val = String(
      "�}�;\u{1b}\u{1a}",
  )
- [ ] Add retries to the peer server given it sometimes refuses a connection;
- [ ] Improve the printing of the logs because its too verbose and breaking line for vectors;
- [ ] Move the download file logic to the BitTorrent to orchestrate the messages with the peers;
- [ ] Create a excalidraw diagram of this whole program;
- [ ] Refactor the types file to split more the logic given it's too big;
- [ ] Improve error handling to do not rely on error return using contains of text.